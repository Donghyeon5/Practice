-- 테이블에 저장할 데이터를 제약하는 특수한 규칙, 데이터의 무결성(DATA INTEGRITY), 정확성과 일관성 보장
-- 특정 열에 부여
-- NOT NULL -> 지정한 열에 NULL 허용 X
-- UNIQUE -> 지정한 열이 유일한 값을 가져야함 중복X NULL은 중복에서 제외
-- PRIMARY KEY -> 지정한 열이 유일한 값이면서 NULL허용 X, 테이블에 하나만 지정가능
-- FOREIGN KEY -> 다른 테이블의 열을 참조하여 존재하는 값만 입력 , 주로 JOIN에 이용
-- CHECK -> 설정한 조건식을 만족하는 데이터만 입력 가능

-- NOT NULL (DEFAULT는 NULL허용)
CREATE TABLE TABLE_NOTNULL(
	LOGIN_ID VARCHAR2(20) NOT NULL,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL VARCHAR(20)
);

SELECT * FROM TABLE_NOTNULL ;

INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', NULL , '010-1111-1111'); --오류 발생 (NOT NULL)
UPDATE TABLE_NOTNULL SET LOGIN_PWD = NULL ;

-- 제약 조건 살펴보기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS ;
-- 제약 조건에 이름 지정하기(테이블명_필드명_유형)
CREATE TABLE TABLE_NOTNULL2(
	LOGIN_ID VARCHAR(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
	LOGIN_PWD VARCHAR(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL,
	TEL VARCHAR2(20)
);
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME ='TABLE_NOTNULL2';

-- 이미 생성한 테이블에 제약 조건 지정
ALTER TABLE TABLE_NOTNULL MODIFY (TEL NOT NULL); --이미 NULL값이 있다면 변경 실패
UPDATE TABLE_NOTNULL  SET TEL ='010-1111-1111' WHERE LOGIN_ID ='TEST_ID_01';

-- 이미 생성한 테이블에 제약 조건 지정
ALTER TABLE TABLE_NOTNULL2 MODIFY(TEL CONSTRAINT TBLNN2_TBL_NN NOT NULL)
-- 이미 생성한 테이블에 제약 조건의 이름 변경하기
ALTER TABLE TABLE_NOTNULL2 RENAME CONSTRAINT TBLNN2_TBL_NN TO TBLNN2_TEL_NN;

-- UNIQUE (KEY역할, NULL은 중복대상에서 제외, 주요 검색 대상, 자동으로 INDEX 생성됨)
-- 해당 컬럼만 따로 정렬된 데이터 -> INDEX

DROP TABLE TABLE_UNIQUE;
CREATE TABLE TABLE_UNIQUE(
 	LOGIN_ID VARCHAR2(20) UNIQUE,
 	LOGIN_PWD VARCHAR2(20) NOT NULL,
 	TEL VARCHAR2(20)
 );
SELECT * FROM TABLE_UNIQUE ;
SELECT OWNER,CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'TABLE_UNIQUE';

INSERT INTO TABLE_UNIQUE(LOGIN_ID,LOGIN_PWD,TEL) VALUES('TEST_ID_03', 'PWD01', '010-1111-1111');
--ORA-00001: unique constraint (SCOTT.SYS_C007024 violated 아이디를 같게하고 실행시 오류, 이전에 실행했던 아이디와 중복되기때문
INSERT INTO TABLE_UNIQUE(LOGIN_ID,LOGIN_PWD,TEL) VALUES( NULL, 'PWD01', '010-1111-1111');
--NULL은 허용함 ,중복 X이기 때문

CREATE TABLE TABLE_UNIQUE2(
 	LOGIN_ID VARCHAR2(20) CONSTRAINT TBLUNIQ2_LGNID_UNQ UNIQUE,
 	LOGIN_PWD VARCHAR2(20)CONSTRAINT TBLUNIQ2_LGNPWD_NN NOT NULL,
 	TEL VARCHAR2(20));

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%'



-- PRIMARY KEY (UNIQUE + NOT NULL을 합친 성격)
-- 데이터 중복X, NULLX, INDEX 자동 생성
-- 모든 테이블은 PRIMARY KEY를 가져야 한다.

CREATE TABLE TABLE_PK(
	LOGIN_ID VARCHAR2(20) PRIMARY KEY,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL VARCHAR2(20)
);
SELECT * FROM TABLE_PK ;

-- 제약 조건의 이름을 직접 지정하여 테이블 생성하기
CREATE TABLE TABLE_PK2(
	LOGIN_ID VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY,
	LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLPK2_LGNPW_NN NOT NULL,
	TEL VARCHAR2(20)
);
SELECT * FROM TABLE_PK2 ;

INSERT INTO TABLE_PK2(LOGIN_ID,LOGIN_PWD,TEL)
VALUES( 'ADDDDAOMEPYO','PWD_01','010-1111-1111');


-- 외래키,외부키 FOREIGN KEY
-- 서로 다른 테이블 간 관계를 정의

-- FOREIGN KEY가 참조하는 열에 존재하지 않는 데이터 입력하기
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(9999,'홍길동','CLERK','7788',TO_DATE('2017/04/30','YYYY/MM/DD'),1200,NULL,50);
-- ORA-02291: integrity constraint (SCOTT.FK_DEPTNO) violated - parent key not found 
-- DEPTNO에 존재하지않은 데이터 50이 입력되어 오류

-- 부모테이블 PK 선언
-- 컬럼 레벨에서 PK 선언
--CREATE TABLE DEPT_FK(
--	DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
--	DNAME VARCHAR2(14),
--	LOC VARCHAR2(13)
--	);

-- 테이블 레벨에서 PK 선언, 마지막에 열이름 추가
CREATE TABLE DEPT_FK(
	DEPTNO NUMBER(2),
	DNAME VARCHAR2(14),
	LOC VARCHAR2(13),
	CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY(DEPTNO)
	);
SELECT * FROM DEPT_FK;

-- 자식테이블 FK 선언

-- 컬럼키 레벨에서 PK, FK 선언
--CREATE TABLE EMP_FK(
--EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
--ENAME VARCHAR2(10),
--JOB VARCHAR2(9),
--MGR NUMBER(4),
--HIREDATE DATE,
--SAL NUMBER(7, 2),
--COMM NUMBER(7, 2),
--DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK(DEPTNO)
--);

-- 테이블 레벨에서 PK, FK 선언
-- FK가 있는 곳이 자식
CREATE TABLE EMP_FK(
	EMPNO NUMBER(4),
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7,2),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2),
	CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY(EMPNO),
	CONSTRAINT EMPFK_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT_FK(DEPTNO)
 );

SELECT * FROM EMP_FK;

-- 먼저 부모에 데이터 삽입후 자식테이블에서 데이터 삽입
INSERT INTO DEPT_FK VALUES(10, 'TEST_NAME', 'TEST_LOC');
-- 부모 데이터에 10, 자식도 10
INSERT INTO EMP_FK VALUES(9999,'TEST_NAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'), 3000,NULL,10);

-- FK로 참조데이터행 삭제하기

-- 자식 테이블에서 10을 가지고 있는 데이터가 있으므로 에러
DELETE FROM DEPT_FK WHERE DEPTNO =10; --오류

-- 부모 테이블에서 삭제할 시 자식 테이블의 해당 데이터도 함께 삭제
-- REFERENCE 참조테이블(참조열) ON DELETE CASECADE

-- 부모 테이블에서 삭제할 때 해당 자식 테이블의 데이터를 NULL로 남기기
-- CONSTRAINT [제약조건이름] REFERENCE 참조테이블(참조열) ON DELETE SET NULL
CONSTRAINT  EMPFK_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT_FK(DEPTNO) ON DELETE SET NULL;





































